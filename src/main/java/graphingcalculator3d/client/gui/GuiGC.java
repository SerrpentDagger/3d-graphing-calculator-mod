package graphingcalculator3d.client.gui;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.util.Random;
import java.util.Scanner;

import org.apache.commons.lang3.ArrayUtils;

import graphingcalculator3d.common.GraphingCalculator3D;
import graphingcalculator3d.common.gameplay.tile.TileGCBase;
import graphingcalculator3d.common.util.config.ConfigVars;
import graphingcalculator3d.common.util.math.expression.EvalInfo;
import graphingcalculator3d.common.util.math.expression.Evaluations;
import graphingcalculator3d.common.util.math.expression.Expression;
import graphingcalculator3d.common.util.math.expression.Expression.Evaluation;
import graphingcalculator3d.common.util.networking.GCPacketHandler;
import graphingcalculator3d.common.util.networking.packets.PacketGC;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.GuiTextField;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiGC extends GuiScreen
{
	static final ResourceLocation CALC_BACK = new ResourceLocation(GraphingCalculator3D.MODID + ":textures/gui/calc_back.png");
	
	/*static final String FUNCTION = "Function: String form of a function. The syntax is as follows: Number of expressions within, evaluation to perform on inner expressions, inner expressions."
			+ " To express a value such as x, z, or 10, use 0VAL([j,k]), where 'j' is the constant or variable, and 'k' states whether 'j' is a variable or not."
			+ " Here is a simple example: 0VAL([x,1]) | Another example: 2MAX(1COS(0VAL([phi,1]))1SIN(0VAL([nu,1]))) | Another example: 2ADD(1SQR(0VAL([2,0]))1SIN(0VAL([phi,1])))"
			+ " You can input special numbers this way, too. For example: 1SINH(0VAL([pi,1])) | Another example: 1SQR_PRSRV(2ADD(0VAL([1,0])0VAL([e,1])))"
			+ " The list of special numbers is as follows: pi, e, a, b, c, gold_r, plank_c, grav_c, boltz_c, avog_c. a, b, and c refer to the variables of those names as defined in the config."
			+ " The list of evaluations is as follows: 2ADD, 2SUB, 1NEG, 2MULT, 1TWICE, 1HALF, 2DIVI, 1ONE_OVR, 1PERCENT, 1SQR, 1SQR_PRSRV, 1SQRT, 1SQRT_POS, 1SQRT_PRSRV, 2PWR, 2PWR_POS, 2PWR_PRSRV, 2ROOT, 2ROOT_POS, 2ROOT_PRSRV, 1EXPONENT, 2REM, 1ABS_VAL, 1SIN, 1COS, 1TAN, 1CSC"
			+ ", 1SEC, 1COT, 1SINH, 1COSH, 1TANH, 1ASIN, 1ACOS, 1ATAN, 1LN, 1LN_POS, 1LN_PRSRV, 1LOG, 1LOG_POS, 1LOG_PRSRV, 1LOG1P, 1INT, 1CEIL, 1FLOOR, 2HYPOT, 2MAX, 2MIN, 1RAN_INT, 2RAN_INT_BTWN, 1RAN_DOUB, 2RAN_DOUB_BTWN, 0RAN_GAUS."
			+ "If you have a suggested addition to anything, I'd be happy to implement it.";*/
	
	static final String FUNCTION = "Function: String form of a function. Automatically generated by the equation blocks. You can copy-paste this into a different calculator"
			+ " if you don't want to copy all the other settings with a memory card item.";
	static final String DOMAINA = "A-Domain: The lower and upper boundaries of the function's A-values.";
	static final String DOMAINB = "B-Domain: The lower and upper boundaries of the function's B-values";
	static final String RANGE = "Range: The lower and upper boundaries of the function's outputs";
	static final String RESOLUTION = "Resolution: The number of points per 1 unit.";
	static final String SCALE = "X-Scale, Y-Scale, Z-Scale: Use this to expand or shrink the graph.";
	static final String TEX = "Texture: The image to stitch onto the graph.";
	static final String RGBA = "RGBA Values, Color Slope?, Transparancy Mode: Red, Green, Blue, Alpha (Opacity), Color graph to reflect slope?, Transparency Mode. Input \"r\" for a random selection. Transparancy Modes:"
			+ " 0 = Auto, 1 = Fast, 2 = Fancy.";
	static final String CROP = "Crop function to range?: If true, will crop values exceeding the range to the range. If false, those values will not be displayed.";
	static final String DISCTHRESH = "Discontinuity Threshold, Aggressive Discontinuity Threshold: Slopes exceeding the first value will be considered discontinuous, and will not be displayed. If the second value is greater than 0, scaled absolute distances between points"
			+ " greater than the second value will not be displayed (useful for cleaning up Bipolar Cylindrical graphs, as an example).";
	static final String TILECOUNT = "Tile Count: The positive integer number of segments over which one (1) texture tile is spread.";
	static final String TRANSLATION = "Translation: Offset in blocks from the origin.";
	static final String ROTATION = "Rotation: Rotation in degrees around the X, Y, and Z axis.";
	static final String COLLISION = "Collide?: Whether or not the graph is collidable.";
	
	static final String PIO4 = "Value of pi/4 for all your copy-paste needs.";
	static final String PIO2 = "Value of pi/2 for all your copy-paste needs.";
	static final String PI = "Value of pi for all your copy-paste needs.";
	static final String PI2 = "Value of 2pi for all your copy-paste needs.";
	static final String PI4 = "Value of 4pi for all your copy-paste needs.";
	static final String EO2 = "Value of e/2 for all your copy-paste needs.";
	static final String E = "Value of e for all your copy-paste needs.";
	static final String E2 = "Value of 2e for all your copy-paste needs.";
	
	static final String VAL = "Value to put into value block. Shift + Click while hovering over the value block to fill it with this value. Special values can be inputtet as well."
			+ " The list of special values is as follows: pi, e, a, b, c, gold_r, plank_c, grav_c, boltz_c, avog_c. The values a, b, and c are defined in the config, while the rest"
			+ " are mathematical constants. Some of them might not be useful for graphing purposes, but I included them anyway, so deal with it.";
	static final String DELETE_SECTION = "Drop a block here to delete it.";
	
	static final String DONE = "Done";
	static final String UNDELETE = "Undelete Block";
	static final String NEXT = "--->";
	static final String PREV = "<---";
	
	int id = 0;
	
	HashMap<GuiTextField, String> fieldToString = new HashMap<GuiTextField, String>();
	
	public Expression expression;
	public TileGCBase tile;
	private int erroredBox;
	
	protected boolean dragging = false;
	protected ExpressionBlock draggedBlock;
	protected boolean modified = false;
	protected boolean tooltipDrawing = false;
	protected String currentTooltip = "";
	
	public Section spawnSection;
	public Section deleteSection;
	private ArrayList<ExpressionBlock> deleteList = new ArrayList<ExpressionBlock>();
	int pageInd = 0;
	int maxPage;
	
	int guiX = 0;
	int guiY = 0;
	int guiWidth = 0;
	int guiHeight = 0;
	int fieldWidth = 160;
	int blockSpawnY = 210;
	TextButton done;
	TextButton next;
	TextButton prev;
	TextButton undelete;
	
	GuiTextField function;
	GuiTextField domainA;
	GuiTextField domainB;
	GuiTextField range;
	GuiTextField resolution;
	GuiTextField scale;
	GuiTextField tex;
	GuiTextField rgba;
	GuiTextField cropToRange;
	GuiTextField discThresh;
	GuiTextField tileCount;
	GuiTextField translation;
	GuiTextField rotation;
	GuiTextField collision;
	
	GuiTextField piO4;
	GuiTextField piO2;
	GuiTextField pi;
	GuiTextField pi2;
	GuiTextField pi4;
	GuiTextField eO2;
	GuiTextField e;
	GuiTextField e2;
	
	GuiTextField valField;
	
	GuiTextField[] textFields = new GuiTextField[] {};
	
	VisibleImage background;
	NumberFormat f = NumberFormat.getInstance();
	
	public GuiGC(TileGCBase tile)
	{
		this.tile = tile;
	}
	
	@Override
	public void initGui()
	{
		mc.renderEngine.bindTexture(CALC_BACK);
		
		guiWidth = (int) (this.width / 1.01);
		guiHeight = (int) (this.height / 1.01);
		
		guiX = SetupGui.centerVal(0, width, guiWidth);
		guiY = SetupGui.centerVal(0, height, guiHeight);
		
		background = new VisibleImage(guiX, guiY, CALC_BACK, true, guiWidth, guiHeight);
		
		done = new TextButton(++id, guiX + guiWidth - 33, guiY + 135 + 3, fontRenderer.getStringWidth(DONE), fontRenderer.FONT_HEIGHT, DONE);
		
		function = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 3, guiWidth - 6, done.defaultHeight);
		domainA = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 15 + 3, fieldWidth, done.defaultHeight);
		range = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 30 + 3, fieldWidth, done.defaultHeight);
		domainB = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 45 + 3, fieldWidth, done.defaultHeight);
		resolution = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 60 + 3, fieldWidth, done.defaultHeight);
		rgba = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 75 + 3, fieldWidth, done.defaultHeight);
		tex = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 90 + 3, fieldWidth, done.defaultHeight);
		tileCount = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 105 + 3, fieldWidth, done.defaultHeight);
		cropToRange = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 120 + 3, fieldWidth, done.defaultHeight);
		discThresh = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 135 + 3, fieldWidth, done.defaultHeight);
		scale = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 150 + 3, fieldWidth, done.defaultHeight);
		translation = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 165 + 3, fieldWidth, done.defaultHeight);
		rotation = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 180 + 3, fieldWidth, done.defaultHeight);
		collision = new GuiTextField(++id, mc.fontRenderer, guiX + 3, guiY + 195 + 3, fieldWidth, done.defaultHeight);
		
		piO4 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 15 + 3, 30, done.defaultHeight);
		piO2 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 30 + 3, 30, done.defaultHeight);
		pi = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 45 + 3, 30, done.defaultHeight);
		pi2 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 60 + 3, 30, done.defaultHeight);
		pi4 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 75 + 3, 30, done.defaultHeight);
		eO2 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 90 + 3, 30, done.defaultHeight);
		e = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 105 + 3, 30, done.defaultHeight);
		e2 = new GuiTextField(++id, mc.fontRenderer, guiX + guiWidth - 33, guiY + 120 + 3, 30, done.defaultHeight);
		
		spawnSection = new Section(guiX + fieldWidth + 6, guiY + 15 + 2, piO4.x - 3 - guiX - fieldWidth - 6, 117);
		deleteSection = new Section(guiX + guiWidth - 20 - 3, guiY + guiHeight - 20 - 3, 20, 20);
		
		int tempX = 3;
		int tempY = 3;
		int tempPage = 0;
		for (Evaluation current : Evaluations.ordered)
		{
			if (current == null)
				continue;
			EvalInfo info = Evaluations.infoMap.get(current);
			if (info == null)
				continue;
			BlockSpawner spawn = new BlockSpawner(id++, 0, 0, info.string, info.slots, info.eval, this, info.rgb[0], info.rgb[1], info.rgb[2])
					.setOnPage(true);
			ExpressionBlock block = spawn.spawn(id++);
			block.arrange(0, 0);
			if (spawnSection.x + tempX + block.width + 3 > spawnSection.right)
			{
				tempX = 3;
				tempY = tempY + block.height + 3;
			}
			if (spawnSection.y + tempY + block.height + 3 >= spawnSection.down)
			{
				tempY = 3;
				tempPage++;
			}
			spawn.setPage(tempPage);
			spawn.x = spawnSection.x + tempX;
			spawn.y = spawnSection.y + tempY;
			block.arrange(spawnSection.x + tempX, spawnSection.y + tempY);
			block.page = spawn.page;
			if (block.page != 0)
				block.visible = false;
			tempX = tempX + block.width + 3;
		}
		maxPage = tempPage;
		
		if (tile.getFunction() != null)
		{
			ExpressionBlock tempBlock = ExpressionBlock.blockFromExpression(id++, tile.getFunction(), this);
			id = tempBlock.gennedID;
			tempBlock.arrange(guiX + 3, blockSpawnY + 3);
			tempBlock.setMoved(true);
		}
		
		valField = new GuiTextField(++id, mc.fontRenderer, spawnSection.x + (spawnSection.width / 2) - 15, spawnSection.down + 3, 30,
				done.defaultHeight);
		
		next = new TextButton(++id, valField.x + valField.width + 3, valField.y, fontRenderer.getStringWidth(NEXT), fontRenderer.FONT_HEIGHT, NEXT);
		prev = new TextButton(++id, valField.x - fontRenderer.getStringWidth(PREV) - 3, valField.y, fontRenderer.getStringWidth(PREV),
				fontRenderer.FONT_HEIGHT, PREV);
		undelete = new TextButton(++id, (int) (valField.x + (0.5 * valField.width) - (0.5 * fontRenderer.getStringWidth(UNDELETE))),
				valField.y + 14, fontRenderer.getStringWidth(UNDELETE), fontRenderer.FONT_HEIGHT, UNDELETE);
		
		done.visible = true;
		next.visible = true;
		prev.visible = true;
		undelete.visible = true;
		
		fieldToString.put(function, FUNCTION);
		fieldToString.put(domainA, DOMAINA);
		fieldToString.put(domainB, DOMAINB);
		fieldToString.put(range, RANGE);
		fieldToString.put(resolution, RESOLUTION);
		fieldToString.put(scale, SCALE);
		fieldToString.put(tex, TEX);
		fieldToString.put(rgba, RGBA);
		fieldToString.put(cropToRange, CROP);
		fieldToString.put(discThresh, DISCTHRESH);
		fieldToString.put(tileCount, TILECOUNT);
		fieldToString.put(translation, TRANSLATION);
		fieldToString.put(rotation, ROTATION);
		fieldToString.put(valField, VAL);
		fieldToString.put(collision, COLLISION);
		
		fieldToString.put(piO4, PIO4);
		fieldToString.put(piO2, PIO2);
		fieldToString.put(pi, PI);
		fieldToString.put(pi2, PI2);
		fieldToString.put(pi4, PI4);
		fieldToString.put(eO2, EO2);
		fieldToString.put(e, E);
		fieldToString.put(e2, E2);
		
		textFields = new GuiTextField[] {};
		textFields = ArrayUtils.add(textFields, function);
		textFields = ArrayUtils.add(textFields, domainA);
		textFields = ArrayUtils.add(textFields, range);
		textFields = ArrayUtils.add(textFields, domainB);
		textFields = ArrayUtils.add(textFields, resolution);
		textFields = ArrayUtils.add(textFields, rgba);
		textFields = ArrayUtils.add(textFields, tex);
		textFields = ArrayUtils.add(textFields, tileCount);
		textFields = ArrayUtils.add(textFields, cropToRange);
		textFields = ArrayUtils.add(textFields, discThresh);
		textFields = ArrayUtils.add(textFields, scale);
		textFields = ArrayUtils.add(textFields, translation);
		textFields = ArrayUtils.add(textFields, rotation);
		textFields = ArrayUtils.add(textFields, valField);
		textFields = ArrayUtils.add(textFields, collision);
		
		textFields = ArrayUtils.add(textFields, piO4);
		textFields = ArrayUtils.add(textFields, piO2);
		textFields = ArrayUtils.add(textFields, pi);
		textFields = ArrayUtils.add(textFields, pi2);
		textFields = ArrayUtils.add(textFields, pi4);
		textFields = ArrayUtils.add(textFields, eO2);
		textFields = ArrayUtils.add(textFields, e);
		textFields = ArrayUtils.add(textFields, e2);
		
		for (GuiTextField field : textFields)
		{
			field.setVisible(true);
			field.setMaxStringLength(1500);
		}
		
		if (tile.isErrored())
			function.setText(tile.getErroredFunction());
		if (tile.getFunction() != null)
			if (tile.getFunction() != null)
				function.setText(tile.getFunction().writeToString());
			
		f.setMaximumFractionDigits(ConfigVars.GraphingConfigs.decPlaces);
		
		domainA.setText("" + f.format(tile.getDomainA()[0]) + " " + f.format(tile.getDomainA()[1]));
		domainB.setText("" + f.format(tile.getDomainB()[0]) + " " + f.format(tile.getDomainB()[1]));
		range.setText("" + f.format(tile.getRange()[0]) + " " + f.format(tile.getRange()[1]));
		resolution.setText("" + f.format(tile.getResolution()));
		scale.setText(f.format(tile.scale[0]) + " " + f.format(tile.scale[1]) + " " + f.format(tile.scale[2]));
		tex.setText(tile.tex);
		rgba.setText(tile.rgba[0] + " " + tile.rgba[1] + " " + tile.rgba[2] + " " + tile.rgba[3] + " " + tile.colorSlope + " " + tile.rgba[4]);
		cropToRange.setText("" + tile.cropToRange());
		discThresh.setText("" + f.format(tile.getDiscThresh()) + " " + f.format(tile.getAggDiscThresh()));
		tileCount.setText("" + tile.tileCount);
		translation.setText(f.format(tile.translation[0]) + " " + f.format(tile.translation[1]) + " " + f.format(tile.translation[2]));
		rotation.setText(f.format(tile.rotation[0] * 180 / Math.PI) + " " + f.format(tile.rotation[1] * 180 / Math.PI) + " " + f.format(tile.rotation[2] * 180 / Math.PI));
		collision.setText("" + tile.collision);
		
		piO4.setText("" + f.format(Math.PI / 4));
		piO2.setText("" + f.format(Math.PI / 2));
		pi.setText("" + f.format(Math.PI));
		pi2.setText("" + f.format(2 * Math.PI));
		pi4.setText("" + f.format(4 * Math.PI));
		eO2.setText("" + f.format(Math.E / 2));
		e.setText("" + f.format(Math.E));
		e2.setText("" + f.format(2 * Math.E));
		
		valField.setText("");
		
		domainA.setCursorPosition(0);
		domainB.setCursorPosition(0);
		tex.setCursorPosition(0);
		
		piO4.setCursorPosition(0);
		piO2.setCursorPosition(0);
		pi.setCursorPosition(0);
		pi2.setCursorPosition(0);
		pi4.setCursorPosition(0);
		eO2.setCursorPosition(0);
		e.setCursorPosition(0);
		e2.setCursorPosition(0);
		
		function.setFocused(true);
		
		buttonList.add(done);
		buttonList.add(next);
		buttonList.add(prev);
		buttonList.add(undelete);
		
		updateBlockStrings();
	}
	
	@Override
	public void drawScreen(int mouseX, int mouseY, float renderPartials)
	{
		modified = false;
		background.draw();
		spawnSection.drawSection(40, 40, 40);
		deleteSection.drawSection(255, 0, 0);
		for (GuiTextField field : textFields)
		{
			field.drawTextBox();
		}
		
		for (GuiButton current : buttonList)
		{
			current.drawButton(mc, mouseX, mouseY, renderPartials);
		}
		
		if (tile.isErrored())
		{
			mc.fontRenderer.drawSplitString("Error: " + tile.getErrorMessage(), guiX + 3,
					guiY + guiHeight - 1 - (mc.fontRenderer.getWordWrappedHeight("Error: " + tile.getErrorMessage(), guiWidth - deleteSection.width - 9)),
					guiWidth - deleteSection.width - 9, 0xFF0000);
			GuiTextField erroredField = textFields[erroredBox];
			Section sec = new Section(erroredField.x, erroredField.y, erroredField.width, erroredField.height);
			sec.drawSection(255, 0, 0, 100);
		}
		
		if (dragging)
			draggedBlock.drawButton(mc, mouseX, mouseY, renderPartials);
		
		for (GuiTextField current : textFields)
		{
			if (dragging)
				break;
			if (mouseX > current.x + current.width - 10 && mouseX < current.x + current.width && mouseY > current.y
					&& mouseY < current.y + current.height)
			{
				mc.currentScreen.drawHoveringText(fieldToString.get(current), current.x + current.width, current.y + current.height);
			}
		}
		for (GuiButton current : buttonList)
		{
			if (dragging)
				break;
			if (current instanceof ExpressionBlock)
			{
				ExpressionBlock block = (ExpressionBlock) current;
				if (block.whole(mouseX, mouseY) && !block.moved && block.visible)
				{
					mc.currentScreen.drawHoveringText(Evaluations.infoMap.get(block.expression.evaluation).tooltip, guiX - 7,
							rotation.y + rotation.height + 15 + 5);
				}
			}
		}
		
		if (deleteSection.isPointWithinIncl(mouseX, mouseY))
			mc.currentScreen.drawHoveringText(DELETE_SECTION, deleteSection.x, deleteSection.y);
	}
	
	@Override
	public void updateScreen()
	{
		for (GuiTextField field : textFields)
		{
			field.updateCursorCounter();
		}
	}
	
	@Override
	protected void actionPerformed(GuiButton button)
	{
		if (button.equals(done))
		{
			done();
		}
		else if (button.equals(next))
		{
			pageInd++;
		}
		else if (button.equals(prev))
		{
			pageInd--;
		}
		else if (button.equals(undelete))
		{
			unDeleteBlock();
			return;
		}
		if (pageInd > maxPage)
			pageInd = 0;
		if (pageInd < 0)
			pageInd = maxPage;
		for (GuiButton current : buttonList)
		{
			if (current instanceof ExpressionBlock)
			{
				ExpressionBlock block = (ExpressionBlock) current;
				if (block.onPage)
				{
					block.visible = block.page == pageInd;
				}
			}
		}
	}
	
	@Override
	protected void keyTyped(char typedChar, int keyCode) throws IOException
	{
		super.keyTyped(typedChar, keyCode);
		
		for (GuiTextField field : textFields)
		{
			field.textboxKeyTyped(typedChar, keyCode);
		}
		
		if (GuiScreen.isShiftKeyDown())
		{
			if (keyCode == 15) // tab
			{
				backOne();
			}
			else if (keyCode == 208) // down
			{
				forwardOne();
				forwardOne();
				forwardOne();
			}
			else if (keyCode == 200) // up
			{
				backOne();
				backOne();
				backOne();
			}
		}
		else if (GuiScreen.isAltKeyDown())
		{
			if (keyCode == 203) // left
			{
				skipInTextField(-4);
			}
			else if (keyCode == 205) // right
			{
				skipInTextField(4);
			}
		}
		else if (keyCode == 15 || keyCode == 208) // tab || down arrow
		{
			forwardOne();
		}
		else if (keyCode == 200) // up arrow
		{
			backOne();
		}
		else if (keyCode == 28) // enter
		{
			done();
		}
		else if (keyCode == 19) // r
		{
			unDeleteBlock();
		}
	}
	
	@Override
	protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException
	{
		if (GuiScreen.isShiftKeyDown())
		{
			ExpressionBlock block = this.getBlockAt(mouseX, mouseY, true);
			if (block == null)
				return;
			if (block.slots.length == 0 && block.expression.evaluation == Evaluations.VAL)
			{
				Scanner boxScan = new Scanner(valField.getText());
				if (boxScan.hasNextDouble())
				{
					block.expression.setValueValue("" + boxScan.nextDouble(), false);
				}
				else if (boxScan.hasNext())
				{
					block.expression.setValueValue(boxScan.next(), true);
				}
				block.displayString = block.expression.getValueValue();
				block.arrange(block.x, block.y);
				boxScan.close();
			}
			return;
		}
		else if (GuiScreen.isCtrlKeyDown() && !dragging)
		{
			ExpressionBlock clickedBlock = this.getBlockAt(mouseX, mouseY, true);
			if (clickedBlock == null)
				return;
			ExpressionBlock dupedBlock = clickedBlock.duplicate(id++);
			id = clickedBlock.gennedID;
			dupedBlock.arrange(guiX + 3, 195 + 3);
			dupedBlock.setMoved(true);
			this.setDragging(dupedBlock);
			return;
		}
		else if (GuiScreen.isAltKeyDown() && !dragging)
		{
			ExpressionBlock clickedBlock = this.getBlockAt(mouseX, mouseY, true);
			if (clickedBlock == null || spawnSection.isPointWithinIncl(mouseX, mouseY))
				return;
			deleteBlock(clickedBlock);
			return;
		}
		super.mouseClicked(mouseX, mouseY, mouseButton);
		for (GuiTextField field : textFields)
		{
			field.mouseClicked(mouseX, mouseY, mouseButton);
		}
	}
	
	public void backOne()
	{
		for (int i = 0; i < textFields.length; i++)
		{
			if (textFields[i].isFocused())
			{
				textFields[i].setFocused(false);
				if (i - 1 >= 0)
					textFields[i - 1].setFocused(true);
				else
					textFields[textFields.length - 1].setFocused(true);
				break;
			}
		}
		
	}
	
	public void forwardOne()
	{
		for (int i = 0; i < textFields.length; i++)
		{
			if (textFields[i].isFocused())
			{
				textFields[i].setFocused(false);
				if (i + 1 < textFields.length)
					textFields[i + 1].setFocused(true);
				else
					textFields[0].setFocused(true);
				break;
			}
		}
		
	}
	
	public void skipInTextField(int chars)
	{
		for (int i = 0; i < textFields.length; i++)
		{
			if (textFields[i].isFocused())
			{
				textFields[i].setCursorPosition(textFields[i].getCursorPosition() + chars);
				break;
			}
		}
	}
	
	public void done()
	{
		int box = 0;
		try
		{
			tile.setErrored(false);
			tile.renderReady = false;
			expression = Expression.parseFromChars(function.getText());
			tile.setFunctionText(function.getText());
			ExpressionBlock block = null;
			if (unslottetBlockCount() > 1)
				setErrored("Loose equation blocks. Reduce the function to a single block.");
			block = this.getFunctionExpression();
			if (block != null)
			{
				tile.setFunction(block.getExpression());
			}
			else
			{
				tile.setFunction(expression);
			}
			box++;
			
			Scanner boxScan = new Scanner(domainA.getText().replaceAll(",", ""));
			for (int i = 0; i < 2; i++)
			{
				if (boxScan.hasNextFloat())
					tile.domainA[i] = boxScan.nextFloat();
				else
					setErrored("Invalid X-Domain Array. Please enter two (2) floats.");
			}
			box++;
			boxScan.close();
			boxScan = new Scanner(range.getText().replaceAll(",", ""));
			for (int i = 0; i < 2; i++)
			{
				if (boxScan.hasNextFloat())
					tile.range[i] = boxScan.nextFloat();
				else
					setErrored("Invalid Range Array. Please enter two (2) floats.");
			}
			box++;
			boxScan.close();
			boxScan = new Scanner(domainB.getText().replaceAll(",", ""));
			for (int i = 0; i < 2; i++)
			{
				if (boxScan.hasNextFloat())
					tile.domainB[i] = boxScan.nextFloat();
				else
					setErrored("Invalid Z-Domain Array. Please enter two (2) floats.");
			}
			box++;
			boxScan.close();
			
			tile.setResolution((float) Double.parseDouble(resolution.getText().replaceAll(",", "")));
			box++;
			
			boxScan = new Scanner(rgba.getText().replaceAll(",", ""));
			for (int i = 0; i < 5; i++)
			{
				if (rgba.getText().charAt(0) == "r".charAt(0))
				{
					Random ran = new Random();
					for (int j = 0; j < 3; j++)
					{
						tile.rgba[j] = ran.nextInt(255);
					}
					tile.rgba[3] = ran.nextInt(125) + 130;
					break;
				}
				if (boxScan.hasNextInt() && i != 4)
					tile.rgba[i] = boxScan.nextInt();
				else if (i != 4)
					setErrored("Invalid RGBA Array. Please enter four (4) integers, a boolean, and one (1) more integer.");
				else
				{
					tile.colorSlope = boxScan.nextBoolean();
					if (boxScan.hasNextInt())
						tile.rgba[4] = boxScan.nextInt();
					else
						setErrored("Invalid RGBA Array. Please enter four (4) integers, a boolean, and one (1) more integer.");
				}
			}
			box++;
			boxScan.close();
			
			tile.tex = tex.getText();
			box++;
			int temp = Integer.parseInt(tileCount.getText().replaceAll(",", ""));
			tile.tileCount = temp < 1 ? 1 : temp;
			box++;
			
			tile.cropToRange(Boolean.parseBoolean(cropToRange.getText()));
			box++;
			
			boxScan = new Scanner(discThresh.getText().replaceAll(",", ""));
			if (boxScan.hasNextDouble())
				tile.setDiscThresh(boxScan.nextDouble());
			else
				setErrored("Invalid Discontinuity Threshold. Please enter a double as the first value in the text field.");
			if (boxScan.hasNextDouble())
				tile.setAggDiscThresh(boxScan.nextDouble());
			else
				setErrored("Invalid Aggressive Discontinuity Threshold. Please enter a double as the second value in the text field.");
			box++;
			boxScan.close();
			
			boxScan = new Scanner(scale.getText().replaceAll(",", ""));
			for (int i = 0; i < 3; i++)
			{
				if (boxScan.hasNextDouble())
					tile.scale[i] = boxScan.nextDouble();
				else
					setErrored("Invalid Scale Array. Please enter three (3) doubles.");
			}
			box++;
			boxScan.close();
			boxScan = new Scanner(translation.getText().replaceAll(",", ""));
			for (int i = 0; i < 3; i++)
			{
				if (boxScan.hasNextDouble())
					tile.translation[i] = boxScan.nextDouble();
				else
					setErrored("Invalid Translation Array. Please enter three (3) doubles.");
			}
			box++;
			boxScan.close();
			
			boxScan = new Scanner(rotation.getText().replaceAll(",", ""));
			for (int i = 0; i < 3; i++)
			{
				if (boxScan.hasNextDouble())
					tile.rotation[i] = boxScan.nextDouble() * Math.PI / 180;
				else
					setErrored("Invalid Rotation Array. Please enter three (3) doubles.");
			}
			box++;
			boxScan.close();
			
			tile.collision = Boolean.parseBoolean(collision.getText());
			box++;
			
			tile.genMesh();
			mc.displayGuiScreen(null);
			
			GCPacketHandler.GRAPH_SYNC.sendToServer(new PacketGC(tile));
		}
		catch (NumberFormatException e)
		{
			tile.setErrored(true, "Invalid number formatting. Field #" + box);
			erroredBox = box;
			tile.setErroredFunction(function.getText());
			e.printStackTrace();
		}
		catch (InputMismatchException e)
		{
			tile.setErrored(true, "Invalid boolean. Field #" + box);
			erroredBox = box;
			tile.setErroredFunction(function.getText());
			e.printStackTrace();
		}
		catch (GuiParseException e)
		{
			tile.setErrored(true, tile.getErrorMessage() + " Field #" + box);
			erroredBox = box;
			tile.setErroredFunction(function.getText());
			e.printStackTrace();
		}
	}
	
	public void button(GuiButton button)
	{
		buttonList.add(button);
	}
	
	public void setDragging(ExpressionBlock block)
	{
		if (!modified)
		{
			if (dragging)
				return;
			dragging = true;
			draggedBlock = block;
			draggedBlock.dragged = true;
			draggedBlock.onPage = false;
			modified = true;
		}
	}
	
	public void blockDropped()
	{
		if (!modified)
		{
			if (spawnSection.isPointWithinIncl(draggedBlock.x, draggedBlock.y))
				return;
			dragging = false;
			draggedBlock.dragged = false;
			if (deleteSection.isPointWithinIncl(draggedBlock.x, draggedBlock.y))
				deleteBlock(draggedBlock);
			draggedBlock = null;
			modified = true;
		}
	}
	
	public void updateBlockStrings()
	{
		ExpressionBlock block = this.getFunctionExpression();
		if (block == null)
			return;
		Expression expr = block.getExpression();
		if (expr == null)
			return;
		
		expr.prepareSeries();
		
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
			{
				ExpressionBlock b = ((ExpressionBlock) buttonList.get(i));
				b.updateStringVars();
			}
		}
	}
	
	public boolean isSlotAt(int x, int y)
	{
		boolean b = false;
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
			{
				b = ((ExpressionBlock) buttonList.get(i)).slotNotWhole(x, y);
				if (b)
					return true;
			}
		}
		return false;
	}
	
	public ExpressionBlock getBlockAt(int x, int y, boolean excludeDragged)
	{
		ExpressionBlock temp = null;
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
				if (((ExpressionBlock) buttonList.get(i)).wholeNotSlot(x, y) && (buttonList.get(i) != draggedBlock || !excludeDragged) && buttonList.get(i).visible)
					temp = (ExpressionBlock) buttonList.get(i);
		}
		return temp;
	}
	
	public ExpressionBlock getWholeBlockAt(int x, int y, boolean excludeDragged)
	{
		ExpressionBlock temp = null;
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
				if (((ExpressionBlock) buttonList.get(i)).whole(x, y) && (buttonList.get(i) != draggedBlock || !excludeDragged))
					temp = (ExpressionBlock) buttonList.get(i);
		}
		return temp;
	}
	
	public boolean slottingReqAt(int x, int y)
	{
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock && buttonList.get(i) != draggedBlock)
			{
				ExpressionBlock block = (ExpressionBlock) buttonList.get(i);
				if (!block.slotNotWhole(x, y))
					continue;
				int s = block.getSlotNumAt(x, y);
				if (!block.slotFull(s))
				{
					block.setBlock(s, draggedBlock);
					return true;
				}
			}
		}
		return false;
	}
	
	public ExpressionBlock getFunctionExpression()
	{
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
			{
				ExpressionBlock block = (ExpressionBlock) buttonList.get(i);
				if (!block.slotted && block.moved && block.visible)
					return block;
			}
		}
		return null;
	}
	
	public void removeButton(GuiButton button)
	{
		buttonList.remove(button);
	}
	
	public void setTooltipDrawing(boolean drawing, String tipIn)
	{
		tooltipDrawing = drawing;
		currentTooltip = tipIn;
	}
	
	public int unslottetBlockCount()
	{
		int count = 0;
		for (int i = 0; i < buttonList.size(); i++)
		{
			if (buttonList.get(i) instanceof ExpressionBlock)
			{
				ExpressionBlock block = (ExpressionBlock) buttonList.get(i);
				if (!block.slotted && block.moved && block.visible)
					count++;
			}
		}
		return count;
	}
	
	public void deleteBlock(ExpressionBlock block)
	{
		deleteList.add(block);
		block.delete(true);
	}
	
	public void unDeleteBlock()
	{
		if (!(deleteList.size() > 0))
			return;
		ExpressionBlock block = deleteList.get(deleteList.size() - 1);
		if (block != null)
		{
			block.unDelete();
			block.arrange(block.x, block.y);
			block.setMoved(true);
			deleteList.remove(block);
		}
	}
	
	public void setErrored(String errorMessage) throws GuiParseException
	{
		tile.setErrored(true, errorMessage);
		throw new GuiParseException(errorMessage);
	}
}
